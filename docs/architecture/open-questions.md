# Open Questions

Use this file **only** to capture currently open medium- or high-impact questions.
It is a **temporary scratchpad for open questions**, not a permanent record of decisions.

Hard rules:

- This table may only contain rows whose status is `Open`.
- When a question is resolved, its outcome **must be captured** in the relevant
  spec's normative artefacts (`spec.md`, `plan.md`) or in an ADR under `docs/decisions/`,
  and the corresponding row **must be deleted** from this file.
- Resolved questions **must not be archived** here; any details must be removed when
  the row is removed.
- Question IDs (e.g., `Q-001`) are local to this project and chat transcripts;
  they must never be referenced from external docs.
- This file is **never** a source of truth; once resolved, no record remains here.
- When presenting a question to a human, use the **Decision Card** format from
  `docs/architecture/spec-guidelines/open-questions-format.md`.

<!-- Add new rows below with Status set to Open only. Remove the row once resolved and documented elsewhere. -->

| ID | Owner | Question | Options (A preferred) | Status | Asked | Notes |
|----|-------|----------|------------------------|--------|-------|-------|
| Q-022 | Ivan | **Content-Type negotiation beyond JSON**: The spec says the engine operates on `JsonNode` (FR-001-04), and N-001-01 excludes XML. But what happens when a request has `Content-Type: application/x-www-form-urlencoded` (common for OAuth token endpoints) or `multipart/form-data`? The spec is silent on form body handling. | A) Core engine only processes `application/json` and `application/*+json`. For form-encoded bodies, the adapter converts form params to a JSON object (e.g., `{"grant_type":"authorization_code","code":"abc"}`) before passing to the engine. Document this as an adapter responsibility in FR-001-04. B) Add `Content-Type: application/x-www-form-urlencoded` as a supported input type with automatic JSON coercion in the core. C) Leave as-is — form bodies are silently skipped via passthrough (FR-001-06). | Open | 2026-02-07 | Severity: MEDIUM — OAuth token endpoints use form-encoded bodies. PingAM's `/access_token` endpoint is form-encoded. If we want to transform token responses, we need to handle the request side too. |
| Q-023 | Ivan | **Multi-value header access**: FR-001-10 says `$headers."Set-Cookie"` returns the first value and "accessing all values requires a future extension." Is this documented well enough, or should we define the exact future API now? Real-world scenarios: `Set-Cookie` always has multiple values, `X-Forwarded-For` chains multiple IPs. | A) Define the multi-value API now as `$headers_all` (a JsonNode where values are arrays of strings) but mark it as **deferred implementation** — document the shape so adapters can prepare for it. B) Ship single-value only and defer entirely. The workaround is header-to-body injection via the adapter. C) Change `$headers` to always use arrays (breaking); this is the most honest representation. | Open | 2026-02-07 | Severity: LOW-MEDIUM — `Set-Cookie` and `X-Forwarded-For` are the main multi-value headers. Most transform scenarios only need request headers which are typically single-value. |
| Q-024 | Ivan | **Error type hierarchy underspecified**: The spec mentions `ExpressionCompileException` and `ExpressionEvalException` (FR-001-02 Java interface) but doesn't define a complete error hierarchy. Missing: `SpecLoadException`, `ProfileLoadException`, `SchemaValidationException`, `MatchResolutionException`, `SensitivePathSyntaxError` (from S-001-62). Should the spec enumerate the full error type catalogue? | A) Yes — add an **Error Catalogue** section with each error type, when it occurs (load/evaluation), severity, and the engine's response. This is essential for adapter implementors. B) Define only the SPI boundary types (`CompileException`, `EvalException`) and leave internal errors to implementation. C) Defer to implementation planning — document error types in `plan.md` instead. | Open | 2026-02-07 | Severity: MEDIUM — adapter implementors need to know exactly which exceptions to catch and how to respond. PingAccess specifically needs `Outcome.CONTINUE` vs `Outcome.DENY` mapping. |
| Q-025 | Ivan | **Lenient mode is underspecified**: FR-001-07 says lenient mode "uses partial output where possible." What exactly is "partial output"? If a JSLT expression fails mid-evaluation (e.g., null pointer on `.callbacks[0].type`), JSLT returns `null` for that sub-expression — is the entire result the "partial output"? What if schema validation fails in lenient mode — pass the malformed output through? | A) Define lenient mode precisely: "If body transform fails, pass original body through unchanged (same as strict). Lenient only affects schema validation — input/output schema mismatches are logged but not aborted." This makes lenient = skip schema checks only. B) "Lenient mode passes whatever the expression produced, even if it's `null` or violates the output schema." This is riskier. C) Remove lenient mode entirely and only support strict. Simplifies the spec significantly. | Open | 2026-02-07 | Severity: HIGH — this is a production safety concern. "Partial output" without a clear definition is dangerous. |
| Q-026 | Ivan | **GatewayAdapter SPI lifecycle gaps**: The SPI defines `wrapRequest`, `wrapResponse`, and `applyChanges` (SPI-001-04/05/06). Missing lifecycle methods: how does an adapter **initialize** (load profiles and specs at gateway startup)? How does it **shut down** (release compiled expressions)? How does it receive a **reload** trigger from the gateway? The spec defers adaptation to per-gateway feature specs, but the core SPI should define the lifecycle contract. | A) Add `GatewayAdapter.initialize(EngineConfig)` and `GatewayAdapter.shutdown()` to the SPI. Keep `reload()` on the engine itself (already in NFR-001-05) — adapters call `engine.reload()` when the gateway signals a config change. B) Define a separate `AdapterLifecycle` SPI that extends `GatewayAdapter`. C) Leave lifecycle to each adapter's feature spec — the core doesn't need to define it. | Open | 2026-02-07 | Severity: MEDIUM — PingAccess has `configure(PluginConfiguration)` + `@PostConstruct`; PingGateway has filter `init()`; standalone has main() bootstrap. A common lifecycle contract would help consistency. |
| Q-027 | Ivan | **Cross-profile match conflicts**: ADR-0006 defines match resolution for entries **within** a single profile. But what happens if two **different profiles** both match the same request? E.g., `pingam-auth.yaml` and `pingam-legacy.yaml` both have entries matching `POST /json/*/authenticate`. Is this a load-time error, or does profile load order win? | A) Cross-profile conflicts are a **load-time error** — the engine validates that no two profiles produce ambiguous matches for any possible request. If profiles overlap, the operator must merge them or add more specific constraints. B) Profile load order wins (first-match). This is simpler but error-prone. C) Profile-level priority field (e.g., `priority: 100`) for explicit disambiguation. D) Defer to profile chaining — both profiles execute in sequence. | Open | 2026-02-07 | Severity: HIGH — this is a real operational risk. When multiple teams author profiles independently, overlapping matches are inevitable. The spec needs a clear answer. |
